

## 🛠️ 이커머스 도메인 설계 및 아키텍처 구조 설정

이 PR에서는 이커머스 시스템의 전반적인 아키텍처 구조와 도메인 모델을 정의했습니다.
개발 초기 단계로서 구조적 일관성과 향후 확장 가능성을 고려하되, 현재 필요한 수준까지만 추상화를 적용했습니다.

---

### 1️⃣ 아키텍처 구조

* **기반 구조**:  `Layered Architecture`
* **설계 원칙**:

  * 도메인 간 의존성은 직접 참조하지 않고 `Reader`, `Facade`를 통해 간접 처리
  * 모든 API 응답은 `ApiResponse<T>`, `ApiErrorResponse`, `ApiResponseCode` 포맷을 통해 일관성 유지
  * 테스트, 외부 연동 등 확장성 고려는 하되, 과도한 추상화는 배제

---

### 2️⃣ 패키지 구조 및 구성 이유

```text
kr.hhplus.be.server
├── common         → 공통 응답 포맷, 예외 처리, 상수 등
├── user           → 사용자 도메인
├── pointhistory   → 포인트 이력 도메인
├── coupon         → 사용자 보유 쿠폰
├── couponpolicy   → 쿠폰 정책
├── product        → 상품
├── order          → 주문, 주문 상세, 결제 내역
├── infra.external.order       → 외부 주문 연동
```

* 각 도메인은 `controller`, `service`, `domain`, `dto`, `reader`, `facade` 구조로 분리
* 도메인 패키지 안에 `@Entity`와 `JpaRepository` 포함하여 응집도 유지

---

###  2️⃣-1️⃣  전체 요청 처리 흐름

프로젝트는 도메인 중심 계층 구조를 따르며, 각 요청은 다음과 같은 흐름으로 처리

```
Controller → (Facade) → Service → Reader → Repository → Domain
                                    ↘︎        ↑
                                     → 다른 Service / Facade (필요 시)
```

#### 각 계층의 역할

| 계층           | 설명                                 |
| ------------ | ---------------------------------- |
| `Controller` | 외부 API 요청 진입 지점. 파라미터 처리 및 응답 반환   |
| `Facade`     | 복합 도메인 로직 조율. 여러 Service 호출 조합     |
| `Service`    | 단일 도메인 비즈니스 로직 처리                  |
| `Reader`     | 읽기 전용 조회 인터페이스. 도메인 간 직접 참조 방지     |
| `Repository` | JPA 기반 데이터 접근 계층                   |
| `Domain`     | 상태와 행위를 가지는 핵심 비즈니스 모델 (@Entity 등) |

---

#### 🎫 쿠폰 발급 흐름

```
CouponController
 → CouponPolicyFacade (쿠폰 발급 전체 흐름)
    → CouponPolicyReader (쿠폰 정책 조회)
    → UserReader (유저 조회)
    → CouponPolicy (도메인에서 수량 차감)
    → CouponService (쿠폰 생성 및 저장)
        → Coupon (도메인 객체 생성)
        → CouponRepository (쿠폰 영속화)
    → CouponResponseDto (응답 변환)

```

#### 🛒 주문 생성 흐름

```
OrderController
 → OrderFacade(주문 요청 전체 흐름)
    → UserReader (유저 조회)
    → ProductReader (재고 조회 및 차감)
    → CouponReader (쿠폰 조회)
    → CouponPolicyReader (할인율 조회)
    → OrderService (주문 + 결제 저장)
    → ExternalOrderSender (외부 전송)

```

---

#### 💡 설계 의도

* `Facade`: 도메인 간 흐름을 명확히 분리해 책임 집중
* `Reader`: 읽기 의존을 명시적으로 관리해 결합도 최소화
* `Service`: 도메인 단위의 비즈니스 책임 분리



---

### 3️⃣ Repository 인터페이스 분리 생략 이유

* 현재 도메인 로직이 복잡하지 않아 `JpaRepository`를 직접 사용함
* 당장 `Reader`, `Store` 등의 인터페이스 계층을 만들 경우 오히려 개발 복잡도만 증가
* 테스트/확장/외부 인프라 대응이 필요한 시점에 리팩토링 예정
* 기준: **"Repository는 직접 사용하되, 도메인 간 직접 참조는 금지"**

---

### 4️⃣ `User` vs `PointHistory` 분리 이유

#### 📌 서로 다른 책임 (SRP)

* `User`: 현재 상태(포인트 포함) 관리 → 주 객체
* `PointHistory`: 포인트 충전/사용 기록 추적 → 로그성 보조 객체

#### 📌 생명주기 다름

| 항목 | User     | PointHistory |
| -- | -------- | ------------ |
| 생성 | 회원 가입 시  | 포인트 충전/사용 시  |
| 소멸 | 회원 탈퇴 시  | 유지 (삭제 X)    |
| 목적 | 현재 정보 관리 | 과거 내역 보존     |

→ `PointHistory`는 회계적 기록 역할로, 유저 삭제 이후에도 남겨야 하므로 도메인과 패키지를 분리

---

### 5️⃣ `Order` 하위에 `OrderItem`, `OrderPayment` 포함 이유

#### 📌 연관된 책임 (SRP)

* `Order`: 주문 전체 흐름 관리 → 주 객체
* `OrderItem`: 상품/수량 등 주문 상세 → 내부 구성 요소
* `OrderPayment`: 결제 정보(쿠폰, 최종 금액 등) → 주문과 함께 처리되는 부속 정보

#### 📌 함께 생성되고 함께 관리됨

| 항목 | Order       | OrderItem / OrderPayment |
| -- | ----------- | ------------------------ |
| 생성 | 주문 생성 시     | 같이 생성됨                   |
| 소멸 | 주문 취소 or 유지 | Order 기준으로 같이 관리됨        |
| 목적 | 주문 전체 흐름 관리 | 세부 정보 보조                 |

→ 연관 구조라 `order` 패키지 안에 같이 포함했고,
`OrderPayment`는 부분취소 등 확장성을 고려하면 **분리도 가능**하지만,
지금은 초보자로서 **구현 난이도 낮추는 걸 우선**으로 해 한 패키지에 구성

---

### 6️⃣ `Coupon` ↔ `CouponPolicy` 연관관계 안 맺은 이유

#### 📌 단방향 ID 참조로 충분함

* 특정 정책 기준으로 쿠폰들을 조회하거나 조작해야 하는 로직이 있음
* 정책 삭제 시 관련 쿠폰들을 **한 번에 삭제/비활성화**하고 싶을 때 유리
* 테스트/통계/관리 페이지(UI) 등에서 **쿠폰 목록을 쉽게 조회**하려는 목적도 있음

→ 연관관계 없이 `couponPolicyId`만 들고 있게 해서
**JPA 의존 줄이고, 쿼리 단순화**

---
### ✅ 추가 구현 방침

* 모든 도메인 객체는 Setter 없이, 생성자 + 도메인 메서드 기반으로 상태 변경
* DTO는 `record` 타입 사용, `from()` 또는 생성자 방식으로 변환 책임 분리
* 추후 외부 연동, 비동기 처리 등은 도메인 확장 이후 구현

---


# 📦 이커머스 서비스 - 설계

Spring Boot 기반 포인트 충전/사용 기능 및 주문 처리, 선착순 쿠폰 발급이 가능한 시스템입니다,

---

## ✨ 주요 기능 요약 (요구사항/제약사항)

- **포인트 충전/조회/사용**
  - 사용자 포인트를 충전하고 현재 잔액 및 충전/사용 이력을 조회할 수 있습니다.
  - 포인트 사용 시 `Optimistic Lock`을 적용해 중복 차감을 방지합니다.

- **상품 조회**
  - 전체 상품 목록 및 개별 상품 상세 정보를 조회할 수 있습니다.
  - 단일 옵션 상품만 제공하며 페이징은 지원하지 않습니다.

- **쿠폰 발급 및 사용**
  - 선착순으로 쿠폰을 발급받을 수 있으며, 보유 쿠폰 목록과 사용 가능 여부를 확인할 수 있습니다.
  - 쿠폰 중복 발급, 만료, 타인 쿠폰 사용은 제한됩니다.

- **주문 및 결제**
  - 사용자는 여러 상품을 선택하여 주문하고 충전된 포인트로 결제할 수 있습니다.
  - 주문 시 상품 재고를 확인하고 차감하며, `Pessimistic Lock`을 적용해 동시 주문 시 재고 초과 방지를 보장합니다.
  - 쿠폰 적용 시 할인 금액이 반영되며, 외부 데이터 플랫폼으로 주문 내역을 전송합니다 (Mock 처리).

- **주문 조회**
  - 전체 주문 내역 및 단건 주문 상세 정보, 결제 내역을 조회할 수 있습니다.

- **동시성 및 제약사항 처리**
  - 잔액 부족, 재고 부족, 쿠폰 무효 등의 상황에 대한 예외 처리를 포함합니다.
  - 멀티 인스턴스 환경 및 동시 요청에도 일관성 있게 동작하도록 설계되었습니다.


---

## 📚 주요 설계 문서

아래 문서들은 `docs/architecture/` 디렉토리에 위치하고, 기능 정의, ERD, API명세서를 정의하였습니다.

| 번호 | 문서명                                                             | 설명 |
|------|-----------------------------------------------------------------|------|
| 0 | [요구사항 정의](docs/architecture/0.요구사항_정의.md)                         | 전체 기능 항목 및 요구사항 개요 |
| 1 | [API 명세서 요약](docs/architecture/1.API명세서_요약.md)                  | 각 기능의 Endpoint 및 응답 요약 |
| 2 | [API 명세서 상세](docs/architecture/2.API명세서_상세.md)                  | 요청/응답/에러 케이스 포함한 상세 명세 |
| 3 | [ERD](docs/architecture/3-1.ERD.png)                            | 전체 DB 테이블 구조 (이미지) |
| 4 | [도메인 클래스 다이어그램](docs/architecture/4-1.domain-class-diagram.png) | 클래스 다이어그램 |
| 5 | [DDL 스크립트](docs/architecture/5.ddl.sql)                         | 테이블 생성용 SQL 스크립트 |


---

## 🛠 기술 스택

- Java 17
- Spring Boot
- MySQL
- Swagger (Springdoc OpenAPI)
- JUnit5
